# Коллоквиум 4 модуль

# Сеть

## 1. Что такое WebSocket и как он отличается от HTTP? В каких случаях целесообразно использовать WebSocket? Опишите процесс установления WebSocket соединения и его закрытия.

**WebSocket** - это  это коммуникационный протокол, предназначенный для реализации постоянного, двунаправленного соединения между клиентом и сервером. В отличие от традиционных HTTP-запросов, которые являются одноразовыми и требуют многократного установления соединения для каждой передачи данных, WebSocket обеспечивает постоянное соединение, что позволяет передавать данные в режиме реального времени.

### Отличия WebSocket от HTTP
Двунаправленность:

- HTTP: Клиент инициирует запрос, сервер отвечает. Это модель запрос-ответ, где каждый обмен данных требует нового HTTP-запроса.
WebSocket: После установления соединения как клиент, так и сервер могут обмениваться данными в любом направлении в любое время без необходимости повторного установления соединения.
Постоянное соединение:

- HTTP: Соединение устанавливается и закрывается для каждого запроса.
WebSocket: Соединение устанавливается один раз и сохраняется до явного закрытия, что позволяет передавать данные с минимальными задержками.
Производительность и масштабируемость:

- HTTP: Каждый запрос содержит заголовки, что увеличивает накладные расходы. Постоянное установление и закрытие соединений также потребляет ресурсы.
WebSocket: Позволяет избежать накладных расходов на установление новых соединений и передачи заголовков, что улучшает производительность, особенно при частом обмене небольшими данными.


### Целесообразность использования WebSocket
WebSocket целесообразно использовать в следующих случаях:

Чат-приложения: Обеспечивает мгновенный обмен сообщениями между пользователями.
Реальное время: Приложения, требующие обновлений в реальном времени, например, финансовые биржи или системы мониторинга.
Онлайн-игры: Обеспечивает низкую задержку и быструю передачу данных между игроками и сервером.
Потоковая передача данных: Потоковая передача мультимедийных данных или данных с датчиков, где важна минимальная задержка.
Коллаборативные приложения: Приложения, где несколько пользователей работают над одним документом в реальном времени.

### Процесс установления WebSocket соединения

1) Инициация соединения:

Клиент отправляет HTTP-запрос с методом GET и заголовком Upgrade, указывающим на желание перейти на протокол WebSocket.

2) Подтверждение от сервера:

Если сервер поддерживает WebSocket и согласен на установление соединения, он отвечает с кодом статуса 101 Switching Protocols, подтверждая обновление протокола.

3) Установление постоянного соединения:

После подтверждения от сервера, соединение считается установленным, и обе стороны могут начинать обмен данными.

### Процесс закрытия WebSocket соединения
1) Инициация закрытия:
Любая сторона (клиент или сервер) может инициировать закрытие соединения, отправив контрольное сообщение с кодом закрытия.

2) Ответное закрытие:
Получив сообщение о закрытии, другая сторона отправляет ответное контрольное сообщение о закрытии.

3) Завершение соединения:
После обмена контрольными сообщениями соединение закрывается, и оба конца освобождают ресурсы, связанные с этим соединением.  


## 2. Что такое STOMP и как он работает поверх WebSocket? Каковы преимущества использования STOMP? Какие основные команды STOMP вы знаете и для чего они используются?

**STOMP** (Simple Text Oriented Messaging Protocol) — это простой текстовый протокол для обмена сообщениями, который работает поверх различных протоколов транспортного уровня, включая WebSocket

WebSocket протокол не определяет форматы сообщений, поддерживает передачу в текстовом виде и bit. 
Поэтому поверх WebSocket используют другие суб-протоколы, например, STOMP. STOMP чем-то похож на HTTP и работает поверх TCP.

### Как работает STOMP поверх WebSocket?
Установление WebSocket соединения:

Клиент устанавливает соединение с сервером, используя WebSocket.
Взаимодействие через STOMP:

После установления WebSocket соединения начинается обмен сообщениями с использованием STOMP.
STOMP использует текстовые фреймы для передачи команд и сообщений. Каждый фрейм состоит из команды, набора заголовков и тела сообщения (если требуется).
Использование команд STOMP:

Команды STOMP отправляются и принимаются через WebSocket соединение, позволяя клиенту и серверу обмениваться информацией и сообщениями.

**Преимущества использования STOMP**
Простота и читаемость:
STOMP использует текстовые сообщения, что делает его простым для понимания и отладки.

Стандартизация:
STOMP предоставляет стандартные команды и заголовки для обмена сообщениями, что упрощает интеграцию с различными системами и брокерами сообщений.

Поддержка различных транспортных протоколов:
STOMP может работать поверх различных транспортных протоколов, включая WebSocket, TCP и HTTP, обеспечивая гибкость в выборе транспортного уровня.

### Основные команды STOMP
- CONNECT:
Использование: Устанавливает соединение с сервером STOMP.

- SEND:
Использование: Отправка сообщения на указанную конечную точку.

- SUBSCRIBE:
Использование: Подписка на указанный канал или очередь для получения сообщений.

- UNSUBSCRIBE:
Использование: Отмена подписки на указанный канал или очередь.

- ACK:
Использование: Подтверждение получения сообщения (при использовании подтверждений сообщений).

- DISCONNECT:
Использование: Закрытие соединения с сервером STOMP.

- MESSAGE:
Использование: Сообщение, отправляемое сервером клиенту по подписке.

## 3. Дайте определение GraphQL. Какие проблемы он решает по сравнению с RESTful API? Опишите основные типы запросов в GraphQL и приведите примеры каждого из них.
GraphQL — это язык запросов к API и среда выполнения. GraphQL позволяет клиентам запрашивать только те данные, которые им действительно нужны, а также предоставляет гибкие и эффективные инструменты для работы с данными.

### Проблемы, которые решает GraphQL по сравнению с RESTful API

- Запрос только необходимых данных:
REST: Обычно возвращает фиксированные структуры данных, что может привести к получению лишних данных.
GraphQL: Клиенты могут запрашивать только те поля, которые им нужны, что уменьшает объем передаваемых данных.

-Объединение нескольких запросов в один:
REST: Получение связанных данных часто требует нескольких запросов к разным конечным точкам.
GraphQL: Позволяет получить все необходимые данные в одном запросе, что снижает количество запросов и ускоряет получение данных.

- Гибкость и версияция:
REST: Добавление новых версий API часто требует создания новых конечных точек или значительных изменений в существующих.
GraphQL: Позволяет добавлять новые поля и типы без нарушения существующих запросов, что упрощает управление версиями.

### Основные типы запросов в GraphQL
- Query (запрос):
Используется для чтения данных.

```
{
  user(id: "1") {
    id
    name
    email
  }
}

```

- Mutation (мутация):
Используется для изменения данных (создание, обновление, удаление).
```
mutation {
  createUser(input: { name: "John Doe", email: "john@example.com" }) {
    id
    name
    email
  }
}
```

- Subscription (подписка):
Используется для подписки на изменения данных в реальном времени.
```
subscription {
  userAdded {
    id
    name
    email
  }
}

```

## 4. Какие недостатки и вызовы могут возникнуть при использовании GraphQL? В каких случаях вы бы рекомендовали использовать REST API вместо GraphQL и почему?

- Проблема N+1 запросов заключается в том, что при выполнении запроса в базу данных отправляется несколько запросов, что приводит к лишней нагрузке на сервер.
- Перегрузка сервера:
Запросы: Клиенты могут отправлять очень сложные или глубоко вложенные запросы, что может привести к значительным нагрузкам на сервер и увеличению времени выполнения запросов.
Защита от злоупотреблений: Требуется внедрение механизмов для предотвращения злоупотреблений, таких как лимиты глубины запросов и ограничение на количество запрашиваемых полей.
- Проблемы с кешированием:
Кеширование: В REST API кеширование можно легко настроить на уровне HTTP, тогда как в GraphQL необходимо внедрять более сложные механизмы кеширования, так как каждый запрос может быть уникальным.
- Серверная часть: Разработка и поддержка GraphQL сервера может быть сложнее, чем RESTful API. Необходимо обеспечить безопасность, контроль доступа и оптимизацию запросов.
Типизация: Нужна четкая схема типов, что требует дополнительных усилий по проектированию и поддержке.

Случаи, когда стоит использовать REST API вместо GraphQL
- Простые API:
Маленькие проекты: Для небольших проектов с простыми и статическими требованиями REST API проще и быстрее в реализации.

- Традиционное кеширование:
Кеширование: Когда требуется использовать стандартные механизмы HTTP кеширования, REST API будет предпочтительнее, так как он лучше поддерживает кеширование на уровне HTTP.

- Ограниченные ресурсы:
Ресурсы разработки: Если команда разработки не имеет опыта работы с GraphQL, может потребоваться больше времени и ресурсов на обучение и внедрение, что не всегда оправдано.

## 5. HTTP/1.1 и HTTP/2?

### Что такое HTTP?

**HTTP (HyperText Transfer Protocol)** — это протокол передачи данных в интернете. Изначально для передачи данных в виде гипертекстовых документов в формате HTML, сегодня — для передачи произвольных данных.

### Разница между HTTP/1.1 и HTTP/2

**HTTP/1.1** был стандартом для передачи данных в Интернете на протяжении многих лет, но он имеет ряд ограничений, которые могут снижать производительность и масштабируемость веб-приложений. **HTTP/2** был разработан для устранения этих ограничений и предлагает ряд улучшений:

- Множественные потоки: В **HTTP/1.1** каждый запрос обрабатывается последовательно, что может привести к задержкам, особенно в условиях высокой загрузки. **HTTP/2** позволяет обрабатывать несколько запросов одновременно в рамках одного соединения, что улучшает производительность.
- Сжатие заголовков: **HTTP/1.1** требует отправку заголовков для каждого запроса, что может быть неэффективным, особенно если заголовки остаются неизменными между запросами. **HTTP/2** использует сжатие заголовков для уменьшения объема передаваемых данных.
- Приоритизация запросов: В **HTTP/1.1** запросы обрабатываются в порядке их поступления, что может привести к задержкам для менее важных запросов. **HTTP/2** позволяет клиенту указывать приоритеты запросов, чтобы сервер мог обрабатывать более важные запросы первыми.
- Серверный пуш: **HTTP/2** вводит концепцию серверного пуша, позволяя серверу активно отправлять данные клиенту без предварительного запроса. Это может улучшить время загрузки веб-страниц, отправляя данные заранее.
- Бинарный протокол: В отличие от **HTTP/1.1**, который использует текстовый протокол, **HTTP/2** является бинарным протоколом. Это упрощает обработку и уменьшает объем передаваемых данных.

**HTTP/2** был разработан для улучшения производительности и масштабируемости веб-приложений, устраняя некоторые из ограничений **HTTP/1.1**. Однако, несмотря на эти улучшения, **HTTP/2** требует поддержки со стороны клиента и сервера, и не все клиенты и серверы могут поддерживать **HTTP/2**.


## 6. Протоколы транспортного уровня: TCP, UDP

**TCP (Transmission Control Protocol)** 

- Протокол надежной и упорядоченной доставки данных
- Обеспечивает контроль передачи данных, управление потоком, обнаружение ошибок и повторную передачу данных при необходимости

**UDP (User Datagram Protocol)**

- Простой протокол без гарантии доставки данных, контроля потока или механизмов повторной передачи данных
- Представляет собой менее надежную альтернативу TCP

### Разница между TCP и UDP

- **Надежность:** TCP обеспечивает надежную передачу данных, используя механизмы подтверждения получения, повторной передачи потерянных пакетов и контроля потока. UDP не предоставляет таких гарантий, что делает его более подходящим для приложений, где скорость важнее надежности, например, в потоковом видео или игровых приложениях
- **Соединение:** TCP использует соединение для обмена данными между отправителем и получателем, что обеспечивает упорядоченную и безошибочную передачу. UDP не использует соединение, что позволяет ему быстрее передавать данные, но также означает, что он не может гарантировать упорядоченность или доставку данных
- **Заголовки:** TCP заголовки содержат больше информации, чем UDP заголовки, включая номера последовательности, контрольные суммы и флаги управления соединением. UDP заголовки значительно меньше и содержат только порты отправителя и получателя
- **Применение:** TCP часто используется в приложениях, где важна надежность и целостность данных, таких как веб-сервисы, электронная почта и файловые передачи. UDP часто используется в приложениях, где скорость важнее, и потеря некоторых пакетов приемлема, например, в потоковом видео, онлайн-играх и VoIP



# Тестирование

## 1. Что такое unit-тестирование и какова его цель? 

**Unit-тестирование (модульное тестирование)** — это процесс тестирования отдельных модулей или компонентов программы для проверки их корректной работы.

### Цель:
- Найти дефекты в компонентах (классы/модули/функции)
- Сформировать уверенность (на каком-то уровне), что компонент
работает
- Заложить базу для следующих уровней тестирования

Объекты тестирования: 
- Классы
- Компоненты, модули

Типичные ошибки/дефекты:
- Проблемы с потоком данных и потоком управления
- Неверная логика
- Не вписываемся в требования

## 2. Как создать и запустить простой unit-тест с использованием JUnit? Что такое аннотация @Test? Какие аннотации JUnit можно использовать при написании тестов? Приведите примеры.

- Пример

**Тестируемый класс**
```
public class Calculator {
    public int add(int a, int b) {
        return a + b;
    }
}
```
**Тестовый класс**
```
import org.junit.Test;
import static org.junit.Assert.assertEquals;

public class CalculatorTest {

    @Test
    public void testAdd() {
        Calculator calculator = new Calculator();
        int result = calculator.add(2, 3);
        assertEquals(5, result);
    }
}

```

**Аннотация @Test** используется для обозначения метода как тестового. Метод, помеченный этой аннотацией, будет выполнен JUnit в процессе тестирования.

Другие аннотации JUnit
- @Before:
Аннотация @Before указывает, что метод должен быть выполнен перед каждым тестом.

- @After:
Аннотация @After указывает, что метод должен быть выполнен после каждого теста.

- @BeforeClass:
Аннотация @BeforeClass указывает, что статический метод должен быть выполнен один раз перед всеми тестами в классе.

- @Ignore:
Аннотация @Ignore указывает, что тестовый метод или класс должны быть пропущены при выполнении тестов.


## 3. Какие проблемы решает Mockito при написании тестов? Как использовать Mockito для создания mock-объектов? Приведите примеры.

-Изоляция тестируемого кода:
Позволяет изолировать тестируемый класс от его зависимостей, что упрощает тестирование и делает его более предсказуемым.

- Замещение реальных зависимостей:
Упрощает создание и настройку зависимостей, заменяя их mock-объектами, что особенно полезно при тестировании классов с внешними зависимостями (например, базы данных, веб-сервисы).
- Контроль над поведением зависимостей:
Позволяет задавать поведение mock-объектов и проверять, как тестируемый класс взаимодействует с ними, что помогает выявлять ошибки в логике.

- Упрощение проверки взаимодействий:
Позволяет проверять, как часто и с какими параметрами вызываются методы зависимостей, что полезно для тестирования правильности выполнения вызовов.

**Создадим пример**, в котором будем тестировать класс CalculatorService, который зависит от MathService.
```
public class CalculatorService {
    private final MathService mathService;

    public CalculatorService(MathService mathService) {
        this.mathService = mathService;
    }

    public int add(int a, int b) {
        return mathService.add(a, b);
    }

    public int multiply(int a, int b) {
        return mathService.multiply(a, b);
    }
}
```
```
public interface MathService {
    int add(int a, int b);
    int multiply(int a, int b);
}
```

Написание тестов с использованием Mockito
```
public class CalculatorServiceTest {

    private MathService mathService;
    private CalculatorService calculatorService;

    @Before
    public void setUp() {
        // Создаем mock-объект для MathService
        mathService = Mockito.mock(MathService.class);
        // Создаем экземпляр CalculatorService с mock-объектом MathService
        calculatorService = new CalculatorService(mathService);
    }

    @Test
    public void testAdd() {
        // Задаем поведение mock-объекта
        when(mathService.add(2, 3)).thenReturn(5);

        // Вызываем тестируемый метод
        int result = calculatorService.add(2, 3);

        // Проверяем результат
        assertEquals(5, result);

        // Проверяем взаимодействие с mock-объектом
        verify(mathService).add(2, 3);
    }

    @Test
    public void testMultiply() {
        // Задаем поведение mock-объекта
        when(mathService.multiply(2, 3)).thenReturn(6);

        // Вызываем тестируемый метод
        int result = calculatorService.multiply(2, 3);

        // Проверяем результат
        assertEquals(6, result);

        // Проверяем взаимодействие с mock-объектом
        verify(mathService).multiply(2, 3);
    }
}
```

## 4. В чем разница между @Mock и @InjectMocks аннотациями в Mockito? Какие основные методы Mockito используются для задания поведения mock-объектов?

**@Mock**
Аннотация @Mock используется для создания mock-объектов. Эти объекты являются заменителями реальных объектов и позволяют задавать их поведение и проверки взаимодействий.

```
public class CalculatorServiceTest {

    @Mock
    private MathService mathService;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testAdd() {
        when(mathService.add(2, 3)).thenReturn(5);
        // остальной код теста
    }
}
```

**@InjectMocks**
Аннотация @InjectMocks используется для автоматического внедрения (инъекции) mock-объектов, созданных с помощью @Mock, в тестируемый объект. Это упрощает процесс создания и инициализации зависимостей для тестируемого объекта.

```
public class CalculatorServiceTest {

    @Mock
    private MathService mathService;

    @InjectMocks
    private CalculatorService calculatorService;

    @Before
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testAdd() {
        when(mathService.add(2, 3)).thenReturn(5);
        int result = calculatorService.add(2, 3);
        assertEquals(5, result);
        verify(mathService).add(2, 3);
    }
}
```

### Основные методы Mockito для задания поведения mock-объектов

- when(...).thenReturn(...):
Задает возвращаемое значение метода.

```
when(mathService.add(2, 3)).thenReturn(5);
```

- when(...).thenThrow(...):
Задает выбрасываемое исключение методом.
```
when(mathService.add(2, 3)).thenThrow(new RuntimeException("Error"));
```

- doReturn(...).when(...):
Альтернативный способ задания возвращаемого значения, используемый для void-методов или при необходимости задания поведения до вызова метода.
```
doThrow(new RuntimeException("Error")).when(mathService).someVoidMethod();
```

- doAnswer(...).when(...):
Задает кастомное поведение метода.
```
doAnswer(invocation -> {
    Object[] args = invocation.getArguments();
    return (Integer) args[0] + (Integer) args[1];
}).when(mathService).add(anyInt(), anyInt());

```


## 5. Что такое интеграционное тестирование? Объясните разницу между unit-тестами и интеграционными тестами.

**Интеграционное тестирование** — это процесс тестирования взаимодействия между различными модулями или компонентами системы. Целью интеграционного тестирования является выявление дефектов в интерфейсах и взаимодействиях между интегрируемыми частями системы.

Цель: 
- Найти сбои в взаимодействии разных интерфейсов
- Сформировать уверенность в качестве интерфейсов (на каком-то уровне)
- Избежать ошибок на уровнях выше
- Найти дефекты нижнего уровня

### Разница между unit-тестами и интеграционными тестами
- Цель тестирования:
Unit-тесты: Проверяют корректность работы отдельных модулей или функций в изоляции от других частей системы.
Интеграционные тесты: Проверяют взаимодействие и интеграцию нескольких модулей или компонентов системы.

- Уровень изоляции:
Unit-тесты: Высокий уровень изоляции. Тестируемый код изолирован от зависимостей с помощью mock-объектов или заглушек.
Интеграционные тесты: Низкий уровень изоляции. Тестируемые модули взаимодействуют с реальными зависимостями или с частями системы, которые максимально приближены к реальным.

- Область покрытия:
Unit-тесты: Покрывают небольшие части кода (отдельные методы или классы).
Интеграционные тесты: Покрывают взаимодействие между модулями, могут охватывать большие части системы.

- Пример использования:
Unit-тесты: Проверка, что метод calculateSum() возвращает правильный результат.
Интеграционные тесты: Проверка, что модуль обработки платежей корректно взаимодействует с модулем базы данных и внешним API.

- Время выполнения:
Unit-тесты: Обычно выполняются быстро, так как изолированы и не требуют запуска всей системы.
Интеграционные тесты: Могут выполняться дольше, так как требуют настройки и взаимодействия с внешними системами или другими частями приложения.

## 6. Инструменты для написания тестов: JUnit и Mockito

**JUnit** — это фреймворк для написания и выполнения тестов на языке Java. Он предоставляет аннотации, классы и методы для создания и запуска тестов. JUnit широко используется для unit-тестирования и позволяет легко интегрироваться с другими инструментами, такими как Mockito.

**Mockito** — это библиотека для создания mock-объектов в тестах на языке Java. Она позволяет легко имитировать поведение зависимостей и проверять взаимодействия между ними.

### Основные аннотации Mockito
- @Mock:
Создает mock-объект для зависимости.

- @InjectMocks:
Автоматически внедряет mock-объекты, созданные с помощью @Mock, в тестируемый объект.

- @Spy:
Создает spy-объект, который позволяет следить за реальным объектом и частично изменять его поведение.

- @Captor:
Позволяет захватывать аргументы методов для последующей проверки.

# Безопасность

## 1. Дайте определение понятиям идентификации, аутентификации и авторизации. В чем различие между ними?

**Идентификация** – это процедура распознавания пользователя по еголичному идентификатору. (Кто пользователь?)

**Аутентификация** – процедура проверки подлинности, например: проверка подлинности пользователя путём сравнения введённого им пароля с паролем, сохранённым в базе данных пользовательских логинов. 
(Действительно ли это наш пользователь?)

**Авторизация** – предоставление определённому лицу или группе лиц прав навыполнение определённых действий; а также процесс проверки данных правпри попытке выполнения этих действий.
(К чему есть доступ у этого пользователя?)


## 2. Что такое password-based authentication и какие у нее есть преимущества и недостатки? Объясните, как работает протокол HTTP Basic Authentication.

**Аутентификация по паролю**
Метод аутентификации, который основывается на том, что пользователь должен предоставить логин и пароль для идентификации, а далее для аутентификации. 
Логин и пароль задаются пользователем при регистрации в системе. При использовании этого метода система проверяет, совпадают ли предоставленные учетные данные с сохраненными учетными записями в системе.

**Преимущества password-based authentication:**
- Простота использования: Для пользователей удобно запоминать и использовать пароли.
- Широкое распространение: Этот метод широко используется и поддерживается многими системами и сервисами.
- Относительная стойкость: При использовании достаточно длинных и сложных паролей, этот метод может обеспечить приемлемый уровень безопасности.
- 
**Недостатки password-based authentication:**
- Уязвимость к атакам перебора: Если пароли слишком просты или коротки, они могут быть взломаны атаками перебора.
- Уязвимость к перехвату и атакам посередине: При передаче паролей по незашифрованным каналам они могут быть перехвачены и использованы злоумышленниками.
- Проблемы с безопасностью пароля: Пользователи могут использовать слабые или повторяющиеся пароли, что делает систему уязвимой к атакам.

### HTTP Basic Authentication
1. Клиент хочет аутентифицироваться (отправляет GET-запрос)
2. Сервер отвечает с кодом ошибки 401 (Unathorized), а также отправляет какуюто информацию (realm) в response headere WWW-Authenticate
3. Клиент отправляет на сервер запрос сrequest header-ом Authorization (в котором находятся необходимые для авторизации данные, закодированные в Base64).

![alt text](https://github.com/kkkkkostya/kpo_kollok/blob/8ce6d8e1994a7cdca204aa0b1dc6df8a8b4565dc/%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%202024-06-12%20153948.png)

## 3. Что такое аутентификация по токенам? Приведите пример flow такого способа аутентификации.



## 4. Объясните, что такое Single Sign-On (SSO) и в чем его преимущества.

## 5. Что такое JSON Web Token? Из каких основных частей формируется данный токен?

## 6. Объясните разницу между access-токенами и refresh-токенами (и id-токеном?). Как происходит обновление access-токена с использованием refresh-токена?

## 7. Объясните, как работают фильтры безопасности (security filters) в Spring Security и приведите примеры их использования. Как настроить аутентификацию с использованием JWT в Spring Security?
